---
interface Props {
  src: string;
  alt?: string;
  width?: number;
  class?: string;
  contrast?: number;
}

const { src, alt = '', width = 300, class: className = '', contrast = 1.2 } = Astro.props;
---

<div class={`dithered-container ${className}`} style={`max-width: ${width}px;`}>
  <img 
    src={src} 
    alt={alt} 
    class="dithered-source" 
    crossorigin="anonymous"
    data-contrast={contrast}
  />
  <canvas class="dithered-output"></canvas>
</div>

<script>
  // Atkinson dithering - produces cleaner results like classic Mac
  function applyAtkinsonDithering(ctx: CanvasRenderingContext2D, width: number, height: number, contrast: number) {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // First pass: convert to grayscale and apply contrast
    for (let i = 0; i < data.length; i += 4) {
      let gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      
      // Apply contrast
      gray = ((gray / 255 - 0.5) * contrast + 0.5) * 255;
      gray = Math.max(0, Math.min(255, gray));
      
      data[i] = gray;
      data[i + 1] = gray;
      data[i + 2] = gray;
    }

    // Second pass: Atkinson dithering
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const oldPixel = data[idx];
        const newPixel = oldPixel < 128 ? 0 : 255;
        
        data[idx] = newPixel;
        data[idx + 1] = newPixel;
        data[idx + 2] = newPixel;

        // Atkinson dithering distributes 6/8 of the error (not all of it)
        // This creates cleaner, less noisy results
        const error = (oldPixel - newPixel) / 8;

        // Distribute error to neighboring pixels
        const distribute = (dx: number, dy: number) => {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const nidx = (ny * width + nx) * 4;
            data[nidx] = Math.max(0, Math.min(255, data[nidx] + error));
            data[nidx + 1] = Math.max(0, Math.min(255, data[nidx + 1] + error));
            data[nidx + 2] = Math.max(0, Math.min(255, data[nidx + 2] + error));
          }
        };

        // Atkinson pattern (distributes to 6 neighbors, 1/8 each = 6/8 total)
        distribute(1, 0);   // right
        distribute(2, 0);   // right+1
        distribute(-1, 1);  // bottom-left
        distribute(0, 1);   // bottom
        distribute(1, 1);   // bottom-right
        distribute(0, 2);   // bottom+1
      }
    }

    ctx.putImageData(imageData, 0, 0);
  }

  function initDitheredImages() {
    const containers = document.querySelectorAll('.dithered-container');
    
    containers.forEach((container) => {
      const img = container.querySelector('.dithered-source') as HTMLImageElement;
      const canvas = container.querySelector('.dithered-output') as HTMLCanvasElement;
      
      if (!img || !canvas) return;
      if (canvas.classList.contains('loaded')) return;
      
      const contrast = parseFloat(img.dataset.contrast || '1.2');
      
      const processImage = () => {
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Set canvas size to match image
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;

        // Draw image to canvas
        ctx.drawImage(img, 0, 0);

        // Apply Atkinson dithering (classic Mac style)
        applyAtkinsonDithering(ctx, canvas.width, canvas.height, contrast);

        // Show canvas
        canvas.classList.add('loaded');
      };
      
      if (img.complete && img.naturalWidth > 0) {
        processImage();
      } else {
        img.addEventListener('load', processImage);
      }
    });
  }

  // Run on page load and after navigation
  initDitheredImages();
  document.addEventListener('astro:page-load', initDitheredImages);
</script>

<style>
  .dithered-container {
    position: relative;
    width: 100%;
    line-height: 0;
  }

  .dithered-source {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    width: 100%;
    height: auto;
  }

  .dithered-output {
    width: 100%;
    height: auto;
    opacity: 0;
    transition: opacity 0.3s;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }

  .dithered-output.loaded {
    opacity: 1;
  }
</style>

